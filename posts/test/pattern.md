---
layout: post
title:  "TDD pattern"
date:   2019-08-10 02:02:59
author: Inhyuk
category: test
tags: test
cover:  "/assets/instacode.png"
name: pattern.md
---

테스트
==========


- **시작하기 전에 테스트 할 목록을 적어두자**: 구현해야할 필요가 있는 모든 동작을 적어둔다 -> 존재하지 않는 동작(메서드)에 대해서는 해당 메서드를 빈 메서드로 구현한다 -> 리팩토링 해야할 목록을 적어 놓는다
- **테스트를 미리 전부 만들어 놓는 것은 좋지 않다**: 대부분의 테스트는 리팩토링에 영향을 받기 때문에 지속적인 수정을 요구한다. 또한, 한 번에 여러개의 테스트가 실패하면 수정해야할 사안이 늘어나기 때문에 TDD 주기가 길어진다
- **테스트는 테스트 대상 코드보다 먼저 작성해야 한다**: 테스트를 먼저 작성하면 테스트가 없어서 생기는 스트레스가 줄어들고 테스트를 작성하게 되고 하는 식의 선순환 구조를 만들 수 있다
- **테스트를 작성할 때는 Assert 부터 작성한다**: AAA 중 Assert부터 작성하면, 그 assert를 위해서 필요한 동작(Action)과 그 동작을 위한 준비(Arrange)를 간단하게 작성할 수 있고, 필요 없는 코드 작성을 줄일 수 있다. 코드 배치 순서는 Arrange -> Action -> Assert, 작성 순서는 그 역순인 Assert -> Action -> Arrange

- TDD를 할 때 남의 코드는 웬만하면 하지말아야 한다. 고치지 못할 것이므로
- 다음은 설계에 문제가 있음을 알려주는 테스트의 특징이다
  - 긴 셋업: 하나의 단순한 assert를 위한 arrange가 매우 많다면, 문제가 있는 것
  - 셋업 중복: 공통 setup으로 놓을 이유가 마땅치 않을 때
  - 실행 시간이 오래 걸리는 테스트
  - 깨지기 쉬운 테스트: 테스트가 동작을 테스트 하는 것이 아닌 구현을 테스트하는 과한 명세 상태
- 중복되는 테스트는 2가지 기준에 의해서 삭제할지 말지를 결정하면 된다
  - 테스트를 삭제할 경우 설계에 대한 자신감이 떨어지면 삭제하면 안된다
  - 중복되는 테스트들이 같은 부분을 실행하더라도 다른 내용을 테스트 하는 것이라면 중복되는 테스트가 아니다


- - -

빨간 막대 패턴
=========

- 테스트를 **언제, 어디에** 작성해야 하는 것에 대한 패턴
- **테스트는 구현 할 수 있는 확신이 들고, 무언가 새로운 것을 알려주는 것부터 작성한다**: 아는 것에서 모르는 것으로 테스트를 작성해야 한다
- **첫 테스트 작성은 아무 일도 하지 않는 경우를 먼저 한다**: 가장 간단한 것부터 테스트를 작성해야 한다
- **장애가 발생하면 테스트가 통과할 경우에는 장애가 수정되었다고 봐도 되는 테스트(regression test)를 작성하라**: regression test는 사실 처음부터 작성 되었어야 하는 테스트이다.

- - -

테스팅 패턴
=========

- 지나치게 큰 테스트가 동작을 하지 않으면 작은 테스트로 분할하고 동작하게 작성한 후에 다시 그 큰 테스트를 작성한다. 큰 수정을 요구하는 테스트는 더 세분화한 테스트를 해야한다는 하나의 시그널이다
- 비용이 많이 들거나 지나치게 복잡한 리소스에 의존하는 객체는 Mock을 사용한다
- 테스트의 대상이 되는 객체가 제대로 다른 객체와 통신하는지 보려면 그 다른 객체를 Mock으로 한다
- 발생하기 힘든 에러 상황을 테스트 하기 위해서는 실제 작업을 수행시키지 않고 예외를 발생시키는 객체를 호출하게 한다
- 프로그래밍을 하다가 하루 할 일을 끝낼때는 테스트 하나가 깨진 상태로 끝내는 것이 좋다. 다음에 다시 그 코드를 볼 때 어디서부터 시작해야하는 지를 알려주는 지표가 될 것이다. 물론 다른 사람들과 일을하거나 PR을 올리는 경우에는 성공한 상태로 끝내야 한다.

- - -

초록 막대 패턴
=======

- 깨진 테스트를 성공하게 만드는 코드를 작성하게 하기 위한 패턴이다
- 실패하는 테스트를 작성한 후에 가장 먼저 해야할 일은 상수를 반환하게 가짜로 구현하는 것이다. 테스트가 통과하면 그 상수를 단계적으로 변수를 사용하는 방식으로 교체한다(직접 구현). 추후에 변경을 하므로 YAGNI의 원칙에 위배되지 않는다.
- 삼각측량은 2가지 이상의 예를 만들어서 추상화를 해나가는 방법이다. 감각과 논리에 의존하는 가짜 구현하기와 달리 비교적 합리적인 생각이라고 들 수 있다. 그러나 이는 순환에 빠질 수 있다. ex) 테스트1과 테스트2를 만들고(삼각측량) 그것을 통해서 추상화를 한다면 두 테스트 중 하나는 없어져도 되는 상태가 된다. 그러나 그렇다고 하나의 테스틀 지워버리면 리팩토링 시에 깨질 위험이 있다. 저자는 어떻게 추상화해야할지 감이 안 올 때만 삼각 측량을 사용한다고 하였다.
- 너무 단순한 구현은 가짜 구현하지도 말고 직접 구현하는 것이 좋다
- collection을 이용하는 테스트에서는 하나씩 늘려나가면서 테스트 하는 것이 좋다
- 예외가 발생하는 것이 정상인 경우(checked exception등)에는 예외가 발생하는 상황을 만들고, 그 예외가 발생하지 않으면 실패하게 하는 테스트를 작성한다

- - -

디자인 패턴
========

- 직면하는 대다수의 문제들은 다른 사람들이나 본인이 이미 경험했던 문제들. 그래서 대부분의 문제는 그 문제를 해결하기 위한 패턴이 존재: 디자인 패턴
- 디자인 패턴은 그러나 다양한 생각을 막을 수 있음
- TDD vs Design pattern
  - TDD에서는 리팩토링을 설계의 일종으로 봄
  - Design pattern에서는 설계와 리팩토링을 분리해서 생각

|패턴|테스트|리팩토링|
|-|-|-|
|커맨드|O||
|VO|O||
|템플릿 메서드||O|
|플러거블 객체||O|
|플러거블 셀렉터||O|
|팩토리 메서드|O|O|

Command
-------

- 계산 작업에 대한 호출을 메시지가 아닌 객체로 표현
- 복잡한 계산 작업에 대한 호출을 할 때 사용

VO
----

- 객체를 여러 곳에서 공유해야 하지만 identity는 중요하지 않은 경우에 사용
- 객체내의 값이 같으면 다 같은 객체라고 생각
- 보통은 값 객체에 대한 연산을 수행해도 VO의 값은 변하지 않고 새로운 객체가 생성된다

- VO를 사용하지 않으면 다른 객체에 의한 처리에 의해 공유하는 값이 의도치 않게 변할 수 있다.
  - 항상 새로운 객체를 전달해서 해결할 수 있다. 그러나 이 방법은 계속해서 객체를 만드는 비용이 들고, 객체의 변화를 공유할 때는 사용할 수 없다
  - 옵저버 패턴: 의존하는 객체에 자기를 등록해서 객체의 상태 변경을 통지 받음. 이 방법은 흐름을 파악하기 어렵게 할 수 있다

템플릿 메서드
--------


- 작업 순서는 변하지 않지만 작업 단위에 대한 개선 가능성을 열어두고 싶을 때 사용. 다른 메서드를 호출하는 것으로 표현
- 초기의 설계에서 얻어지는 것보다는 리팩토링 하다가 경험에 의해 발견되는 것이 좋음. 두 하위 클래스의 어떤 연산이 순서는 같고 일부의 연산이 다른 경우가 발견되는 경우에 부모 클래스에서 일부를 제외한 메서드를 구현하고 일부를 자식 클래스에서 구현하도록 해서 구현

플러거블 객체
-------

- 변이를 표현할 때 사용.
- TDD를 할 때 같은 조건문이 2번 이상 발견되는 경우에는 이 객체를 사용한다

플러거블 셀렉션
------------

- 인스턴스 별로 서로 다른 메서드가 동작하게 할 때 사용.
- 메서드의 이름을 저장하고 있다가 그 이름에 해당하는 메서드를 동적 호출.

팩토리 메서드
--------

- 새로운 객체를 만들 때 여러 조건이나 상황이 달라지는 경우에 사용
- 단순 생성자를 사용하면 유연성이 떨어지기 때문에 유연성을 위해서 팩토리 메서드를 사용. 그렇지 않은 경우에는 단순 생성자를 사용하는 것이 좋음
- 단점: 메서드가 생성자 역할을 한다는 사실을 명확하게 알려주지 못한다

- - -

리팩토링
======


- TDD에서는 테스트들을 통과하는 상태를 계속 유지한 상태로 어떤 행위를 하든 그것이 리팩토링이다(다른 방법론에서는 다르게 봄). 그렇기 때문에 테스트가 충분히 있어야 함.
- 리팩토링 시 비슷해 보이는 두 코드 조각은 최대한 닮게 수정한다. 이 수정은 단계별로 이루어져야한다. 단계 없는 수정은 신념에 의한 리팩토링으로 이어질 수 있다
- 표현 양식을 변경하려면 일시적으로 데이터를 중복시킨다. ex) 새로운 인스턴스 변수 추가 -> 기존 인스턴스 변수를 사용하는 모든 곳에서 새로운 인스턴스 변수 사용하도록 수정 -> 기존 변수 삭제 -> 외부 인터페이스 변경
- 길고 복잡한 메서드가 생성되면 긴 메서드의 일부를 별도의 메서드로 분리하고 이를 호출하게 한다. 반대로 메서드가 분산되어 있어서 너무 복잡한 흐름을 가지는 경우에는 기존의 메서드를 인라인 하는 방식으로 리팩토링 한다.
- 메서드가 원래 있어야 할 장소로 이동시키려면 클래스에 메서드를 추가하고 그것을 호출하게 하면 된다. 사용하는 객체가 대상 객체의 메서드나 변수를 2번 이상 호출한다면 고려해 볼만하다.
- 다수의 매개변수와 지역 변수를 갖는 복잡한 메서드는 클래스로 분리시킨다. 객체내에서 메서드 분리하기를 할 수 없는 경우에 사용하면 좋다.
