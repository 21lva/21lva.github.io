---
layout: post
title:  "OOP 관련 내용 정리"
date:   2022-01-22 02:02:59
author: Inhyuk
category: oop
tags: oop
cover:  "/assets/instacode.png"
name: oop_principle.md
---

- 여기는 OOP에 대해서 공부한 내용들을 적어 놓는 곳이다


참고자료
----

- [객체지향의 사실과 오해](http://www.yes24.com/Product/Goods/18249021)

- - -

OOP
=====


설계
---

- 소프트웨어의 설계는 기본적으로 3가지를 생각해야함
  - 실행 중에 제대로 동작해야 한다
  - 변경이 가능해야 한다
  - 코드를 읽는 사람들(미래의 자신 포함)이 이해하기 어렵지 않아야 함: 이해 가능한 코드는 동작이 예상을 벗어나지 않는 코드.

변경에 취약한 코드
----------

- 설계를 할 때 가장 유념에 두어야 할 부분은 변경에 취약하지 않는 설계를 해야한다는 것
- 객체 사이에 **의존성**이 많으면(= **결합도**가 높다), 변경에 취약한 객체 관계가 됨. => 객체를 최소한의 의존성만 가지는 자율적인 존재로 설계하자.

- 가장 중요한 것은 변화에 대한 대응이다. 변화에 유연하게 대응하는 시스템이 좋은 시스템이다. 대부분의 경우에서 변경 가능한 코드가 이해하기 쉬운 코드이다


객체지향 기본 원리
----------

- 보통 많은 사람들이 객체 지향을 현실을 모방하는 것이라고 생각하기 쉽지만 실제로는 그렇지 않다. 객체지향과 현실의 공통점은 협력-책임-역할이라는 구조로 이루어진다는 것이다.
- 협력: 요청과 응답을 통해서 다른 대상과 문제를 해결하는 과정
- 책임: 협력내에서 대상이 맡은 일. 일련의 동작 묶음
- 역할: 책임의 묶음. 대체 가능성을 의미. 하나의 객체는 여러 역할을 맡을 수 있다.
- OOP에서는 최대한 역할을 수행해서 책임을 담당하는 대상이 그 방법을 스스로 선택하도록 해야한다(**캡슐화**). 객체의 자율성은 객체 내부와 외부를 구분하고 외부에서 내부에 일어나는 일에 간섭하지 않도록 하는 과정을 통해서 이루어진다.
- 객체는 책임을 수행하라는 요청을 **메시지** 를 통해서 전달 받고 이 메시지를 처리할 방법(**메서드**)을 스스로 결정해서 수행한다.
- 의인화: 객체는 현실과 달리 모든 자신의 데이터와 관련된 모든 동작을 스스로 수행한다. ex) 현실에서는 요리사가 재료를 전부 다루지만, 객체지향 설계에서는 재료들이 스스로 자신의 변화를 수행해야 할 때가 있다. 좋은 oop는 모든 객체들을 의인화해야한다.

- **클래스** 는 객체지향 언어에서 많이 사용하지만, 객체지향 언어의 필수 요소는 아니다. 즉, 객체지향설계는 클래스가 기반이 아니라 협력을하는 객체를 대상으로 해야한다.(Class oriented programming이 아니다)


절차지향 vs 객체지향
----------------

- 객체지향의 핵심은 객체 내부를 **캡슐화(encapsulation)**해서 객체간의 상호작용을 **메시지(=public interface)**로만 가능하게 하는 것.
- 응집도(cohension): 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에 위임하는 정도. 객체의 응집도를 높이기 위해서는 자신의 데이터와 관련된 모든 작업은 스스로 처리해야 한다.
- 절차지향: 프로세스(메서드, 동작)와 데이터를 별도의 장소(모듈)에 위치시키는 방식. 데이터의 변경으로 인한 부작용의 영향 범위를 예측하기 힘들다.
- 객체지향: 데이터와 프로세스가 동일한 모듈에 위치하도록 하는 프로그래밍 방식.
- 책임의 이동(shift of reponsibility): oop에서는 전체 책임을 맡는 대상(프로세스를 처리하는 객체)가 없고, 그 책임을 여러 객체에 분산시켜서 수행하도록 한다.


- - -

객체지향 설계
==========

- 좋은 설계: 요청-응답의 흐름을 통해서 협력을 설계 -> 요청과 응답으로 책임을 정하고 객체에 책임을 할당 -> 각 객체에서 책임을 수행하기 위해 필요한 데이터 결정 -> 객체를 구현하는 방법을 결정.

협력, 역할, 책임
------------

- 협력은 요청과 응답으로 발생하는 일련의 동작. 요청은 **메시지 전송**을 통해서 이루어진다. 협력은 객체의 상태와 행동(메시지에 대한 응답)을 결정한다. 즉, 협력은 객체를 설계하기 위한 문맥을 제공한다.
- 책임: 협력내에서 객체가 **수행해야하는** 행동. 객체지향설계는 책임을 최적의 객체에 할당하는 것. 알고 있는 것과 할 수 있는 것으로 구성된다. 책임은 객체 외부에 제공해 줄 수 있는 정보와 행동의 목록이며 이 목록들을 위한 내부 동작은 캡슐화 되어 있다. 즉, 책임은 동작이 아니라 책임이 일련의 동작의 묶음이다.
- 책임 vs 메시지: 책임은 객체가 수행할 수 있는 행동의 집합으로 메시지보다 더 추상적인 개념이다. 하나의 책임이 여러 메시지로 분할되기도 한다.
- Information expert pattern: 자율적인 객체를 설계하기 위해서는 책임을 수행하기 위해 필요한 정보를 가장 잘 알고 있는 객체가 해당 책임을 맡아야 한다.
- 역할: 역할은 책임들의 묶음으로 객체로 대체될 수 있는 추상 협력자. 역할을 수행할 수 있는(책임을 수행할 수 있는) 대상들의 묶음이라고 봐도 된다. 하나의 역할에는 여러 책임이 있을 수 있다. 하나의 객체는 여러 역할을 맡을 수 있다. 객체를 교체할 수 있는 일종의 슬롯 역할을 한다. 보통은 abstract class와 interface로 구현한다.
- 역할을 만들면 협력을 추상화할 수 있다. ex) 나 -(부팅하다)-> 맥북 ==추상화==> 인간 -(부팅하다)-> 컴퓨터
- 역할이 명확하지 않으면 먼저 객체로 설계하고, 역할이 필요한 경우에 일반화를 통해서 역할을 설계에 추가하자.
- 역할은 객체의 하나의 일면이다. 객체에는 여러 역할이 부여될 수 있지만, 특정 협력내에서는 객체에게는 하나의 역할만이 허용된다.

- 협력을 설계하는 과정(RDD): 협력을 하나의 책임으로 만들어서 시스템에 할당 -> 시스템에서 recursive로 객체를 선택 => 객체들의 공용 인터페이스가 설계됨
- RDD에서 역할, 책임, 협력을 식별하는 것은 app의 기능을 구현하기 위한 협력관계를 생각하고 그 협력관계에서 가능 먼저 필요한 객체를 찾아 시스템의 책임을 부과하는 것에서부터 시작된다. 객체들은 연쇄적으로 자신의 책임에 필요한 동작과 필요한 다른 대상을 결정한다. 메시지를 먼저 결정하고 수신자의 역할을 결정한다.
- RDD의 장점: 객체가 최소의 인터페이스를 가질 수 있다. 객체가 how가 아닌 what을 의미하는 추상적인 인터페이스를 가질 수 있다.

RDD vs 데이터 주도 설계
------

- RDD(Responsibility-Driven Design): 객체를 설계할 때 객체의 상태가 아니라 객체가 협력에서 수행하는 책임에 집중해서 설계하는 방법론. 상태를 선결할 경우에는 캡슐화가 저해될 수 있고, 협력을 고려하지 않았기 때문에 재사용성이 저하된다.
- DDD(Data-Driven Design): 메시지가 아니라 데이터를 중심으로 객체를 설계하는 방식. 외부에서 객체 내부 상태로의 접근이 가능하게 되면 자율성이 떨어진다. 초보자들은 oop를 설계할 때, 상태를 먼저 결정하고 상태에 필요한 행동을 정의한다. 이는 데이터주도설계이다.
- 데이터 주도 설계를 따르게 되면 OOP에서 중요하게 생각하는 **캡슐화**, **높은 응집도**, **낮은 결합도**를 지키지 못하게 될 확률이 높다.
- RDD에서 역할, 책임, 협력을 식별하는 것은 app의 기능을 구현하기 위한 협력관계를 생각하고 그 협력관계에서 가능 먼저 필요한 객체를 찾아 시스템의 책임을 부과하는 것에서부터 시작된다. 객체들은 연쇄적으로 자신의 책임에 필요한 동작과 필요한 다른 대상을 결정한다. 메시지를 먼저 결정하고 수신자의 역할을 결정한다.

- 데이터 주도 설계의 가장 큰 문제점은
  1. DDD에서는 이른 시기에 데이터의 상태와 위치를 결정한다. 즉, 데이터와 프로세스가 분리된 절차지향적 프로그래밍을 하게 된다.
  2. 협력이라는 문맥을 고려하지 않기 때문에 고립된 객체(객체 섬)을 구성하게 된다.

tradeoff
---------

- 캡슐화: 외부에서 알 필요 없는 부분(데이터, 메서드, 오퍼레이션)을 감추는 것. 변화하는 부분을 감춰서 해당 객체에 의존하는 다른 객체들이 변화에 영향을 받지 않게 하기 위함.
- 응집도: 객체 또는 클래스에 얼마나 관련 높은 책임들이 할당되어 있는지 정도. 응집도가 높다는 것은 하나의 책임이 하나의 객체나 클래스에 있는 정도가 높다는 말이다. 낮은 응집도의 경우에는 변경을 위해서 다른 클래스나 객체를 수정해야 하는 경우가 늘어날 수 있고, A라는 책임에 의한 수정이 발생해도 B라는 책임이 영향을 받을 수도 있다.
- 결합도: 다른 객체나 모듈에 대해서 알고 있는 정도. 결합도가 높을수록 변경에 대응하기 위해 수정이 필요한 객체나 클래스의 수가 많아진다.
- SRP: 객체나 클래스에 대한 변경의 이유는 오직 하나여야 한다. 여기서 responsibility는 위에서 쓰던 책임과는 다른 *변경의 이유*를 의미한다.

자율성
----

- 자율적인 책임은 협력을 단순하게 만든다.
- 자율적인 책임은 객체의 외부와 내부를 명확하게 분리한다. 결국, 내부의 변경에 의한 부작용이 외부로 퍼지는 것을 막을 수 있다.
- 자율적인 책임은 역할을 부여받는 객체들을 선택할때의 유연성을 제공.
- 자율적인 책임은 객체에 응집도를 높게하고, 결합도가 낮아지게 할 수 있다.

상태와 행동
---------

- 객체의 상태는 객체가 겪어온 과거를 함축하는 값.
- 객체의 행동은 상태에 영향을 받고, 상태에 영향을 준다
- 캡슐화: 상태를 캡슐 안에 숨겨서 외부에서 임의로 접근하지 못하도록 한다. 외부에서는 오직 행동을 통해서만 객체와 접근가능하다.

책임 할당하기
-----------

- RDD에서 가장 어려운 과정은 책임에 적절한 객체를 할당하는 것
- DDD: 객체가 포함해야할 데이터 설정 -> 해당 데이터를 처리하는데에 필요한 오퍼레이션 선택
- RDD: 객체가 수행해야할 책임 설정 -> 책임에 필요한 데이터 선택
- 메시지를 먼저 정하고 객체를 할당하는 과정을 거치면, 메시지를 전송하는 객체는 수신자에대한 정보를 알지 못하게 되어서 캡슐화를 위반하지 않는 설계를 할 수 있게 한다.

GRASP(General Responsibility Assignment Software Pattern)
---------

1. 도메인 개념에서 시작한다: 도메인 개념을 개략적으로 그린다. 이 도메인 개념은 초안이고 설계과정 및 코드 구현과정에서 바뀔 수 있다.
2. 정보 전문가에게 책임을 할당한다: 객체가 자신이 소유하고 있는 정보(자신의 데이터와 책임을 수행할 수 있는 다른 객체에대한 정보를 의미)와 관련된 작업을 수행하도록 한다.
3. Low coupling 적용: 현재의 설계가 최소한의 의존성들을 갖게 해야한다.
4. High cohension pattern 적용: 설계가 높은 응집도를 가질 수 있도록 해야한다. 응집도가 높은 객체는 보통 객체의 생성시에 필요한 데이터를 초기화한다. 만약, 함께 초기화 되지 않는 데이터가 있다면 객체로 분리해야 한다는 신호일 수 있다. 또는, 모든 메서드들이 객체의 모든 데이터를 사용하면 응집도가 높은 것이다. 객체의 메서드 그룹이 겹치지 않는 데이터에 따라서 나뉜다면 그 객체는 분할해야한다. 가장 기본적인 신호는 서로 다른 이유로 변경 되면 응집도가 낮다는 것이다.
5. creator 패턴 적용: 객체를 생성하는 책임을 1) 해당 객체를 포함하거나 참조하는 객체 2) 객체를 긴밀하게 사용하는 객체 3) 객체를 초기화하는 데에 필요한 데이터를 아는 객체에게 할당해야한다. 즉, 이미 결합되어 있는 객체에 생성 책임을 할당해서 의존성의 정도를 유지하는 방법이다.
6. 다형성 패턴: 객체의 타입에 따른 조건문(if-else, swith-case)가 존재하면 다형성을 이용해서 분할하자.
7. Protected variations 패턴: 변화가 예상되는 지점을 안정된 인터페이스로 감싸는 패턴. 즉, 변경을 캡슐화한다.

- GRASP에서는 도메인 구조가 선행되어야 한다. 도메인모델이 선행되면 도메인 모델을 반영하는 설계를 할 수 있게 된다. 변경이 일어나는 이유가 도메인모델이 변경이라는 것을 상기해본다면 도메인모델을 반영한 설계가 변경에 대응하기 쉬운 설계라는 것은 직관적으로 이해할 수 있다.
- GRASP에서 만든 도메인 모델의 초안은 설계나 코드를 작성하면 바뀌게 된다. 이는 일시적인 현상이 아닌 도메인에 대한 관점이 변화하는 것이다.

리팩토링을 이용한 설계
--------------

- RDD를 이용하여 설계하는 것은 경험이 풍부해야함
- 경험이 부족하거나 설계가 어려운 구조인 경우에는 데이터 주도 설계로 구현을 하고 **refactoring**을 통해서 캡슐화, 높은 응집도, 낮은 결합도를 갖는 코드로 수정해 나가는 것도 하나의 방법이다.
- 순서: 데이터 중심 설계 -> 몬스터 메서드(프로세스 처리를 담당하는 메서드)를 응집도가 높은 메서드로 분할 -> 응집도 높은 메서드를 각각의 데이터가 자율적으로 사용할 수 있도록 해당 클래스로 이동

- - -

추상화
=====

- 현실의 문제를 그대로 객체로 만드는 것은 좋지 못하다. 협력관계에서 필요한 내용만을 가지는 대상으로 추상화해야한다.
- 추상화는 여러 대상의 공통점을 식별하고 차이점은 무시하는 일반화와 중요한 부분을 제외한 부분을 제거하는 단순화를 통해서 이루어진다.

- 개념: 공통점을 기반으로 객체들을 분류하기 위한 아이디어. 분류된 대상은 그 개념의 인스턴스라고 한다. 타입이라고도 한다.
  - 심볼: 개념을 가리키는 이름. ex) 컴퓨터
  - 내연: 개념을 정의하는 속성. ex) 부품. 동작 등
  - 외연: 개념에 속하는 대상들. ex) 맥북 프로, 데스크탑 등
- 일반화/특수화: 일반화와 특수활르 결정하는 기준은 객체의 상태가 아니라 행동이어야 한다.
- 타입은 객체의 동적인 특성을 추상화하는 방법.
- 클래스: 정적인 타입 *구현*하는 방법 중 하나.


- 추상화에는 2가지가 존재한다: procedure abstraction, data abstraction
  - procedure abstration: 시스템이 무엇을 해야하는지를 추상화. functional decomposition(algorithm decomposition)
  - data abstraction: type abstraction, procedure abstraction(위의 프로시저 추상화랑은 다름)로 나뉜다

```
추상화 - procedure - functional decomposition
     |
     - data - type abstraction -> ADT(abstract data type)
            |
            - procedure abstraction -> OOP
```

프로시저 추상화
-------

- 시스템을 procedure 단위로 분해한다.
- Top-Down으로 최상위 기능을 정의 -> 분해 하는 과정을 재귀적으로 반복하는 과정이다. 이 과정이 끝나면 각 기능에 필요한 데이터를 결정한다.
- 문제점
  1. 시스템이 하나의 main 함수로 구성된다: 시스템은 하나의 main 함수만을 가지지 않는다.
  2. 기능이 추가되는 경우에 main함수부터 재귀적으로 변경해 나가야한다: 기존 로직들이 영향을 받을 수 있다.
  3. 비즈니스 로직이 UI에 강결합: 비즈니스 로직과 UI의 강결합은 변경되는 정도가 다르기 때문에 둘이 결합하지 않도록 해야한다.
  4. top-down 방식을 사용해서 이른 시기에 함수의 실행 순서를 정한다: 하위 함수가 상위 함수의 문맥에 강결합 되고, *what*이 아닌 *how*에 집중하기 때문에 추후에 시간 순서가 변경되면 수정이 힘들어 질 수도 있다. 시간적 제약이 아닌 *논리적 제약*을 기준으로 삼아야 한다.
  5. 데이터의 타입 변경이 일어나는 경우에 너무 많은 부분을 수정해 나가야한다: 함수의 사용 범위를 알 수가 없다.

모듈
---

- 프로시저 추상화의 문제점을 해결하기 위해 나온 방식으로 개별적인 모듈에 퍼블릭 인터페이스를 통한 접근을 허용하도록 하는 설계 방식. 기능 분해가 아닌 변경에 맞는 분해.
- information hiding: 외부에 구현, 데이터 등을 감추고 최소한의 퍼블릭 인터페이스를 통해서만 접근할 수 있게 하는 방식.
- 변경되는 부분들을 모듈내부에 숨기기 때문에 높은 응집도와 낮은 결합돌를 유지할 수 있다.

- 인스턴스를 제공하지 않기 때문에 높은 수준의 추상화를 제공할 수 없다.

ADT
----

- 타입: 변수에 저장할 수 있는 값의 종류와 연산을 의미.
- ADT: 추상 객체의 클래스를 정의한 것. 오퍼레이션을 이용하여 추상 데이터 타입을 정의한다. 추상 객체를 사용할 때는 오직 외부에 제공하는 행위에만 관심을 가지며(), 행위과 구현되는 세부적인 사항은 무시하고(), 구현 정보는 오직 오퍼레이션을 어떻게 구현할 것인지에 집중한다.

OOP
-----

- Class = ADT+상속+다형성

- 아래의 코드는 ADT와 Class의 차이를 보여주는 코드이다. ADT에서는 타입이 추상화의 대상이기 때문에 각 오퍼레이션들이 구체적인 내용을 갖고 있고, class은 행동이 추상화의 대상이기 때문에 구체적인 타입들이 행동을 구현하고 있다. 아래의 코드에서 새로운 유형의 *Customer*가 생길 때 단순히 하나의 구체적인 클래스를 추가하면 되는 후자와 달리 전자의 경우에는 모든 행동을 수정해야한다.
- ADT와 클래스를 구분하는 기준은 클래스 내부에 클래스의 세부 타입을 지정하는 변수가 있어서 해당 변수를 바탕으로 하는 조건문이 메서드에 존재하는 경우에는 ADT라고 할 수 있다.

```kt
//ADT
class Customer{
    fun enterToilet(){
        if(this.isWoman()){
            //구현
        } else {
            // 구현
        }
    }
}

//Class
abstract class Customer{
    abstract fun enterToilet()
}

class Woman: Customer() {
    override fun enterToilet() {
        TODO("Not yet implemented")
    }
}

class Man: Customer() {
    override fun enterToilet() {
        TODO("Not yet implemented")
    }
}
```

- 단순히 Class가 ADT보다 좋다고는 할 수 없다. 가장 먼저 생각해야할 부분은 변경이 얼마나 일어나는지이다. 새로운 타입이 추가되는 경우에는 클래스를, 새로운 오퍼레이션이 추가되는 경우에는 ADT 방식의 설계를 하는 것이 변경에 대응하기 용이하다.



TDD
----

- TDD는 역할을 맡은 객체가 책임을 수행할 때(메시지를 받았을 때) 결과를 반환하고 다른 객체와 협력하는 것에 대한 기대 코드를 작성하는 것. 응집도가 높고 결합도가 낮은 클래스를 구성하는데에 도움이 된다.
- TDD를 하기위해서는 어느 정도의 디자인패턴, RDD에대한 경험이 있어야한다. TDD는 목적지를 도달하는 안정적이고 빠른 방법론이다(물론, TDD를 하다보면 설계에 문제점을 발견할 때가 많다)

다형성
----
- 메서드: 객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법. 객체지향언어에서는 메서드 자체가 함수를 의미하지만 여기서는 그 메서드 내부를 의미한다
- 다형성: 서로 다른 유형의 객체가 동일한 책임을 수행할 때 수행 방법을 다르게 하는 과정을 의미. 결합도를 오로지 메시지에대한 결합으로 낮춰서 유연하고 확장성 있는 구조를 가능하게 한다.

- 다형성은 런타인 의존성을 바탕으로 이루어진다
  - 컴파일타임 의존성: 코드가 작성되고 컴파일 되는 때에 객체간의 관계가 정해지는 의존성. 초기바인딩(=정적바인딩)을 바탕으로 이루어짐. ex) 상속
  - 런타임 의존성: 코드가 동작되는 과정에서 의존성이 결정. lazy binding(=dynamic binding). ex) interface를 상속 받은 객체를 이용하는 경우

What/Who 사이클
-------

- 어떤 책임(메시지)이 필요한지(What) -> 누가 해당 책임을 맡을 것인지(Who). 책임이 먼저 결정되고 그 후에 그 책임을 수행하는 객체를 결정한다.
- 메시지가 모여 객체의 인터페이스를 구성한다. 메시지를 먼저 결정하고 객체를 선택하는 과정은 인터페이스 결정과정을 보여준다.

- - -

인터페이스
=======

- 인터페이스: 객체간의 경계지점. 내부 구조나 동작 방식을 몰라도 되게 해주고, 내부 구조가 변화하더라도 인터페이스 사용자에게는 영향을 미치지 않는다. 인터페이스 내부(구현자) 객체가 바뀌더라도 동일한 인터페이스만 제공하면 되기 때문에 문제가 없어진다.
- 공용 인터페이스: 객체 외부에서 접근 가능한 인터페이스. 객체가 협력에 참여하기 위해서 수행하는 메시지가 객체의 공용 인터페이스를 결정.
- 오퍼레이션: 퍼블릭 인터페이스에 포함된 메시지와 관련 시그니처. 다른 객체에 제공하는 추상적인 서비스
- 메서드: 메세지에 응담하기 위해 실행되는 코드 블록. 오퍼레이션을 구현한 것
- 시그니처: 오퍼레이션의 이름과 매개변수 목록
- 구현: 객체를 구성하는 요소 중 공용 인터페이스를 제외한 요소들.

- 인터페이스를 설계할 때는 (1)최소한의 추상적인 인터페이스 (2)외부에서 사용할 필요가 없는 인터페이스는 노출하지 않도록 최소한의 인터페이스를 고려하고 (3)인터페이스와 구현간에 차이가 있다는 점 등을 고려해야한다.
- separation of interface and implementation: 객체를 공용인터페이스와 구현을 구분해서 설계하는 것. 프로그램은 지속적으로 수정이 필요하다. 객체를 수정하게 되면 객체를 직접 이용하는 부분에서 문제가 발생할 수 있다. 인터페이스를 구현과 구분해서 이러한 변경이 야기하는 부작용이 번져나가는 것을 막을 수 있다.

- 아래의 원칙들은 인터페이스 설계시 지켜야할 원칙이다. **그러나 항상 절대 원칙은 없고 모든 설계는 trade-off라는 것을 유념하고 상황에 맞게 설계를 해야 한다.**

Law of Demeter
--------------

- 객체 내부 구조에 강하게 결합되지 않도록 협력 방법을 제한해야한다는 원칙
- 오직 하나의 **.** 만을 사용해야 한다는 원칙으로도 생각된다. ex) bus.getCustomer().getBag() 는 원칙을 위배한다.
- 캡슐화를 반영하는 원칙이다: 협력하는 클래스의 캡슐화를 지키기 위해서 클라이언트가 접근할 수 있는 객체 내부를 제한하는 원칙
- train wreck: 메시지 전송자가 수신자의 내부 구조에 대해 질문하고 전달받은 요소에 대해서 연속적으로 메시지를 전송하는 것. 클래스 외부에 내부의 요소가 노출되는 형태를 보인다. 이는 캡슐화를 위반한 것

- 물론, 무조건 **.** 을 한 번만 써야하는 것은 아니다: 기차 충돌처럼 보이는 코드가 객체의 내부 구현에 대한 정보를 제공하지 않는다면 디미터 법칙을 위반한 것이 아니다. ex) Builder 패턴, stream 처리
- 반환 하는 대상이 *객체*인지 *자료구조(map, list 등)*인지에 따라 전자는 디미터 법칙을 고려해야하는 대상이고 후자는 내부를 보여줘야하는 대상이기 때문에 그럴 필요가 없다.

Tell, Don't Ask
-----------

- 메시지를 결정하고 객체를 결정하는 과정은 Tell, Don't Ask 방식이다. 책임을 수행할 수 있는지를 묻지 말고 메시지를 결정한 후에 수행 가능한 객체를 결정한다.
- 이 방식은 외부에서 내부의 상태를 알지 않아도 된다(캡슐화). 정확히는 알지 못하기 때문에 질문을 할 수도 없다.
- 가능한지를 질문하는 것은 책임을 수행하는 객체의 내부에 대한 간섭을 하는 것이다. 이는 결합도를 증가시킨다.

- 경우에 따라서 TDA 원칙을 지키는 것이 결합도를 증가시킬 수 있다.
- 아래의 간략한 코드에서 *pushCustomer1*은 TDA 원칙을 위배하고, *pushCustomer2*는 TDA 원칙을 준수한다. 그러나 전자는 *Store*의 *Customer*에 대한 의존성이 존재하지 않지만 후자는 존재한다. 즉, TDA를 지키다가 결합도가 증가한 것이다. TDA도 결국 trade-off가 될 수 있다.

```kt
fun pushCustomer1(store: Store, customer: Customer){
        if(store.open()){
            customer.buy(store.getMedicine())
        }
    }

fun pushCustomer2(store: Store, customer: Customer){
    store.sellMedicine(customer)
}
```

- 또한, 가끔은 묻는 것 이외에는 방법이 존재하지 않는 경우도 있다. 이럴 때에도 TDA를 적용해야한다는 관념에 매몰되면 안된다. 아래의 collection을 순회하는 코드에 해당 경우가 나타나있다.

```kt
fun getPrices(medicines: List<Medicine>) = medicines.sumOf { it.prices }
```

CQRS
-----

- 루틴: 어떤 절차를 묶어 호출 가능하도록 하는 모듈. 프로시저와 함수로 구분됨
  - 프로시저: 정해진 절차에 따라 내부 상태를 변경하는 루틴. 객체 인터페이스에서는 command
  - 함수: 절차에 따라 필요한 값을 계산해서 전달하는 루틴. 객체 인터페이스에서는 query
- 많은 경우에 프로시저와 함수를 구분하지 않고 내부 상태를 변경하면서 값을 전달하거나 반대로 값을 전달하면서 내부 상태를 변경한다. 이럴 경우에는 의도하지 않은 부작용을 야기하거나 thread safe하지 않은 코드를 작성하게 될 수 도 있다.
- CQS(Command-Query separation) 원칙: 객체의 오퍼레이션은 command와 query 둘 중 하나여야 한다는 원칙. TDA에 매몰되지 않을 경우에 적용할 수 있는 원칙
- side effect: 객체의 상태를 변경시키는 동작.
- 참조투명성(referential trasparency): 어떤 표현식을 해당 표현식이 나타나는 모든 경우에 대해서 그 표현식의 값으로 변경해도 결과가 달라지지 않을 때. 참조 투명성을 만족하면 계산 결과가 명확해지고, side effect의 걱정을 하지 않아도 된다는 장점이 생긴다. 그러나 OOP는 side effect를 기반으로 동작하기 때문에 모든 장소에서 side effect를 제거하는 것은 불가능하다. CQS원칙을 준수하여서 최대한의 참조투명성을 가져가도록 노력해야 한다.

의도를 드러내는 인터페이스
-------------

- 메서드(or interface) 이름을 짓는 방법은 *how*가 아니라 *what*을 드러내는 이름을 만드는 것이다.
- *how*에 집중하는 메서드는 협력을 설계하는 그 시점에서부터 이미 구현을 생각하게 되어서 자율적인 객체를 설계하기 힘들어진다.

- 오퍼레이션이 오직 필요한 매개변수, 결과만을 알 수 있도록 명명하자.

- - -

의존성
=====

- transitive dependency: A가 B에 의존하고 B가 C에 의존하면 A는 C에 의존한다. 모든 의존성이 transitive인 것은 아니고 캡슐화가 잘 되어 있는 경우에는 성립하지 않는다. 전이된 의존성을 간접(indirect) 의존성이라고 부른다

- 객체가 다른 객체와 협력을 하고자 한다면 둘 사이에는 의존성이 생긴다. 의존성에는 2가지가 존재
  1. compile time dependency: 코드 생성 및 컴파일 시에 생성되는 의존성.
  2. runtime dependency: 시스템의 실행 시점에 생성되는 의존성.

- 런타임 의존성과 컴파일 타임 의존성의 거리가 유연한 설계이다: 컴파일 의존성은 클래스사이의 의존성이다. 클래스사이의 의존성은 수정하기 힘든 코드로 나타난다. 클래스들의 인스턴스(or 객체)사이의 의존성은 최대한 런타임 의존성으로 해결해야 한다.
- 문맥 독립성: 어떤 클래스 A가 B클래스에 컴파일 타임 의존성을 갖게 되면 B 클래스가 사용되는 문맥(context)에 강결합하게 된다. 즉, 다른 문맥에서는 사용하기 힘든 코드가 되어버리는 것이다. 클래스가 사용되는 문맥을 최소한 하는 것을 *문맥 독립성*이라고 한다. 문맥 독립성은 시스템에서 사용되어지는 객체가 시스템에 관해 모르는 것을 권고한다.

- 숨겨진 의존성: 외부에서 의존관계를 알 수 없는 의존성. 의존성을 파악하기 위해서 코드를 읽어봐야하기 때문에 의존성을 파악하기 힘들고, 의존성이 내부 구현에 따라 결정되기 때문에 지양해야 한다. ex) 메서드 내부에서 생성되는 객체와의 의존성.

- 의존성 주입: 컴파일타임 의존성을 런타임 의존성으로 교체하는 작업(의존성 해결)을 위해 사용되는 방법. 객체를 사용하는 클래스가 아닌 외부에서 객체를 생성 전달해주는 의존성 해결 방법. constructor injection, setter injection, method injection이 존재한다.

- 의존성은 의존성의 정도가 가장 큰 문제이다. 위에서 설명하였듯이 다양한 문맥에서 재사용 가능한 의존성을 설계하는 것이 바람직하다. 결합도는 의존성(컴파일 의존성)의 정도를 의미한다.

- 컴파일타임 의존성과 런타임 의존성의 간격을 넓게하기 위해서는 **구체가 아닌 추상화에 의존하게 해야한다**(Dependency Inversion Principle). 의존하는 대상이 추상화된 정도에 따라서 간격이 넓어진다(추상정도: 구체적인 클래스 < 추상 클래스 < 인터페이스). 의존성 역전 원칙에서 중요한 것은 추상화의 소유권에도 역전 원칙이 적용된다는 것이다. 전통적인 설계에서는 추상 클래스 혹은 인터페이스와 구체 클래스를 같은 패키지에 위치시키지만, DIP를 적용하면 추상 클래스 혹은 인터페이스를 사용 클래스와 같은 패키지에 위치시켜야 한다. 예를 들어, 클래스 A가 B라는 인터페이스에 의존하고 B1,B2의 B를 구현하는 구체 클래스라고 했을 때, A와 B가 같은 패키지에 위치하고 B1,B2는 다른 패키지에 위치해야한다. 즉, 패키지를 변경되는 정도에 따라 나눠야 한다. B1, B2 클래스의 변경으로부터 A와 B를 보호해야한다.

생성
----

- 객체를 생성할 때 *new*를 사용하면 경우에 따라 결합도가 높아질 수 있다: *new*키워드를 사용하여 객체를 생성하면 추상 클래스나 인터페이스가 아닌 구체적인 클래스에 의존해야 하고, 해당 클래스가 의존하는 클래스들에게도 결합도가 생긴다.
- 위의 문제를 해결하기 위해서는 생성과 사용을 분리해야한다. 방법은 2개가 있다.
  1. A라는 클래스에서 사용하는 B라는 클래스의 인스턴스 생성의 책임을 A클래스를 사용하는 사용자에게 부여한다: 사용자 클래스가 A 인스턴스 생성에 필요한 모든 클래스에 대해 의존하고 있을 때만 결합도를 기존과 같게 유지할 수 있는 방법이다.
  2. Factory 추가: 객체를 생성하는 책임만 갖는 factory 객체를 추가하고 사용자가 이 객체에 의존하도록 한다.

- Factory 클래스는 도메인 모델과 관련 없는 기술적인 클래스(pure fabrication)이다. 모든 책임을 도메인 객체들에게 할당하면 유연성 있는 설계를 할 수 없게 된다.

OCP
----

- open-closed principle: 시스템의 요소(모듈, 클래스, 객체, 메서드 등등)은 확장에는 열려 있고, 수정에는 닫혀있어야 한다. 즉, 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야한다는 의미.
- 런타임 의존성과 컴파일 타임 의존성의 거리를 멀리하게 설계를 하면서 추상화에 의존하게 하면 OCP를 만족할 수 있다. 즉, 변경되는 부분이 아닌 추상화에 의존하면 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있게 된다. 추가로 추상화된 부분(인터페이스)는 수정에 대해서 닫혀있어야 한다.

- 물론, OCP에는 여러 논란이 있다. 아래 내용을 참고하자.

#### OCP vs YAGNI

- [OCP VS YAGNI](https://enterprisecraftsmanship.com/posts/ocp-vs-yagni/)
- OCP: open closed principle. 2 가지 버전이 존재
  - Bertrand Meyer의 버전: close의 대상이 외부 사용자
  - Bob Martin의 버전: 기존의 코드를 수정하지 않고 변화하는 것에 대응할 수 있어야함. close의 대상이 기존의 코드
- YAGNI: 현재 필요하지 않는 기능을 더 넣을 필요는 없다. Bob Martin의 방식과 충돌
- YAGNI vs Bob Martins' OCP: APP과 같이 코드가 최종이면 YAGNI가 좋고, library나 framework의 경우에는 Bob Martin의 OCP를 따라야 한다


trade off
--------

- 언제나 유념해두자. **모든 설계 방식은 trade off이다.**
- 유연성 있는 설계를 위해서 DIP, 의존성 주입, OCP 등에 맞는 설계를 하게 되면 복잡도가 증가한다. 변화가 거의 없어서 유연성으로 얻는 변화에 대응하는 능력이 필요 없는 경우와 같은 상황에서는 유연성 있는 복잡한 설계는 시간만 잡아 먹는 애물단지가 될 뿐이다.
- 역할, 책임, 협력을 생각하면서 설계를 해야한다. 그 때 다양한 상황(문맥)에서 협력을 재사용해야할 이유가 없는 경우에는 추상화를 할 필요가 없다.

- - -

재사용성
======

DRY
---

- 중복 코드는 코드의 수정에 드는 리소스를 배로 증가시킨다.
- 중복 코드의 기준은 모양이 아니다. 모양은 중복의 가능성을 보여주는 신호일 뿐이다. 코드가 같은 이유로 변경될 경우에 중복코드라 한다.
- **Don't Repeat Yourself**: 모든 시스템 내의 지식은 단 한 번 명확히 표기되어야 한다. 쉽게말해 중복하지 마라.
- 중복을 제거하기 위해서 많이 사용되는 것이 상속이다

상속
---

- 중복을 제거하기 위해서 상속을 사용하기도 한다. 그러나 상속을 단순히 재사용성을 위해서 사용하지 말자. 상속은 부모 클래스와 자식 클래스의 결합도를 증가시킨다. 자식 클래스가 부모 클래스와 강결합하게 되는 것을 **Fragile base class problem**이라고 한다.
- 취약한 기반 클래스 문제: 자식 클래스가 부모 클래스에 강결합하게 되면서 발생하는 문제.
  1. 자식 클래스가 메서드를 오버라이딩 하는 경우에 부모 클래스에서 해당 메서드를 어떻게 사용하는지를 알아야 하게 되어서 부모 클래스의 구현에 의존하게 된다. 이는 캡슐화를 위반한 설계를 강요한다.
  2. 부모 클래스의 퍼블릭 인터페이스를 전부 구현해야하는 문제가 발생할 수 있다. ex) 자바의 Vector, Stack
  3. 동시 수정 문제: 오버라이딩 하지 않고 퍼블릭 인터페이스 문제가 없더라도 부모 클래스에서 발생하는 변경이 자식 클래스에도 영향을 끼칠 수 있다. 아래는 그 예시이다.

```kt
//기존 코드
open class Barrack{
    private lateinit var marines: List<Soldier>
}

class KoreaBarrack: Barrack(){
    fun give(amount: Int){
        marines.forEach { it.take(amount) }
    }
}


//변경 코드
//medics가 추가되면서 자식 클래스에도 변경이 생겼다.
open class Barrack{
    private lateinit var marines: List<Soldier>
    private lateinit var medics: List<Soldier>
}

class KoreaBarrack: Barrack(){
    fun give(amount: Int){
        marines.forEach { it.take(amount) }
        medics.forEach { it.take(amount) }
    }
}
```


- class explosion: 상속의 남용의 한 예시로서 기능을 추가하기 위해서 많은 수의 클래스를 추가해야 하는 문제. 컴파일타임 의존성으로 결합되는 부모와 자식 클래스는 결국 필요한 조합의 경우 만큼 클래스를 정의해야 한다. 여기서 중요한 것은 클래스의 수가 아니라 조합이 늘어난 만큼 클래스를 정의할 때 발생할 수 있는 중복 코드가 문제인 것이다. A1,A2,A3와 B1,B2,B3를 결합하여 기능을 갖는 클래스를 설계하고자 할 때, 상속을 사용하게 되면 3x3=9개의 자식 클래스를 생성해야 한다. 즉 9개의 코드에서 중복이 3번씩 발생하게 된다.

- 상속을 하기 위해서는 추상화 해야한다: 비슷해 보이는 클래스의 차이점을 추출하고 같은 부분은 동일한 형태로 만든다 -> 중복코드를 바탕으로 추상화를 한다. 이 추상 인터페이스(클래스)에 의존하도록 리팩토링 한다 -> 중복 코드를 부모 클래스로 옮긴다.
- programming by difference: 기존 코드와 다른 부분만을 추가하면서 시스템의 기능을 확장하는 프로그래밍. 중복을 제거하고 코드를 재사용하려는 목적이다. 상속을 이용하면 이 방식으로 프로그래밍할 수 있다. 그러나 상속은 오남용 하는 것은 결국 복잡하지만 수정도 힘든 설계를 만들 수 있다.

합성
-----

- 상속은 **is-a** 관계이고, 합성은 **has-a**의 관계이다.
- 단순 재사용을 위해서는 상속 대신 **합성**을 사용하자. 상속대신 합성을 사용하면 클래스 사이의 결합도를 줄일 수 있다. 상속은 컴파일 타임 의존성이고 합성은 런타임 의존성(구체 클래스가 아닌 인터페이스에 의존하게 만들 수 있기 때문)이다.
- A1,A2,A3와 B1,B2,B3를 결합하여 기능을 갖는 클래스를 설계하고자 할 때, 상속을 사용하게 되면 3x3=9개의 자식 클래스를 생성해야 한다. 그러나 합성을 사용하게 되면 3+3=6개의 클래스만 정의하면 된다.
- 합성을 사용하면 위에서 설명한 상속에서 발생할 수 있는 3가지 문제를 해결할 수 있다
  1. 오버라이딩의 캡슐화 위반:  사용자(기존의 자식 클래스)에서는 사용되는 클래스(기존의 부모 클래스)의 정보를 알 필요가 없다.
  2. 불필요한 퍼블릭 인터페이스 구현: 상속을 하지 않기 때문에 불필요한 인터페이스는 구현할 필요가 없다.
  3. 동시 수정 문제: 부모 클래스 구현의 수정이 자식클래스에 변화를 초래하지 않는다.

믹스인
-----

- 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣는 재사용 기법
- 스칼라에서 trait을 사용한 믹스인은 믹스될 수 있는 클래스에 제한을 둔다(해당 trait을 구현한 클래스). 합성과 달리 클래스의 구조를 표현하면서도 상속과 달리 유연성 있는 런타임 의존성을 갖게할 수 있다.
- 클래스 폭발 문제는 믹스인에서 나타나지 않는다: 클래스 폭발 문제는 클래스의 숫자가 아니라 클래스를 조합할 때 발생할 수 있는 중복코드가 문제였고, 믹스인 방식을 사용하게 되면 조합을 할 때에도 중복 코드가 발생하지 않는다.

서브 클래싱 vs 서브 타이핑
--------------------

- 상속은 재사용성 + 타입 계층 구현의 측면이다. 재사용성만을 위한다면 합성을 사용해야한다. 즉, 상속은 다형성을 제공하는 타입 계층을 구성하는 것이 주된 사용 목적이다.
- OOP에서의 타입: 개념적인 관점에서의 타입 + 프로그래밍 언어에서의 타입. 객체의 타입은 객체의 상태나 속성이 아닌 객체의 퍼블릭 인터페이스에 따라 달라진다. 즉, 동일판 퍼블릭 인터페이스를 제공하면 동일한 타입이다.
  1. 개념적인 타입: 심볼(이름) + 내연(정보) + 외연(타입 대상)
  2. 프로그래밍 관점에서의 타입: 데이터, 오퍼레이션, 오퍼레이션이 적용될 수 있는 문맥에 대한 정보
- OOP에서의 슈퍼타입과 서브타입: OOP에서의 슈퍼타입은 서브 타입이 정의한 퍼블릭 인터페이스를 **일반화(generalization)** 시키는 것. 서브 타입은 슈퍼타입의 퍼블릭 인터페이스를 **특수화(specialization)**

- 서브 클래싱: 클래스를 재사용할 목적으로 상속을 하는 경우. 구현 상속 혹은 클래스 상속이라고 부른다.
- 서브 타이핑: 타입 계층을 구현하기 위해서 이루어지는 상속. 인터페이스 상속이라고도 부른다. 다음을 만족할 때 서브 타이핑이 이루어진다.
  1. 상속관계가 is-a 관계: 단순히 자연언어에서의 is-a가 아니라 행동에 따라 타입을 구성해야 한다. ex) 펭귄 is 새. 새는 날 수 있다. 그러나 펭귄은 날 수 없다.
  2. 행동 호환성: 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용 가능. 클라이언트의 행동호환성 관점에서 타입 계층을 설계해야 한다. 인터페이스를 클라이언트가 기대에 따라 분리되게 계층을 분리 설계 해야한다(**Interface Segregation Principle**)

리스코프 치환 원칙
---------

- Liskov Substitution Principle: 클라이언트 관점에서 제공하는 동작의 차이가 없어서 서브타입으로 슈퍼타입으로 대체할 수 있어야한다는 원칙. ex) 사각형과 정사각형은 LSP를 만족하지 않는다. 정사각형 객체에 width와 height를 각각 수정하고 면적을 계산하면 원하는 결과를 얻지 못할 수 도 있다.
- LSP를 만족해야 사용자 입장에서 사용하는 서브 타입이 무엇인지 알 필요 없이 동작할 수 있기 때문에 슈퍼 타입의 인터페이스에만 의존하는 행동을 할 수 있게 된다. 클라이언트가 슈퍼타입에만 의존하기 때문에 서브 타입을 사용하는 사용자들에게 영향을 끼치지않고 수정 및 추가하기가 용이해진다. 즉, LSP는 OCP를 위한 전제조건이다.

- 계약에 의한 설계(Design By Contract): 사용하고 호출되는 클래스들 사이의 의무와 이익으로 구성된 계약에 의해서 설계하는 것.
  - 사전조건(precondition): 클라이언트가 정상적으로 메서드를 호출하기 위해 달성해야하는 조건
  - 사후조건(procondition): 메서드 제공자가 클라이언트에게 보장해야하는 조건
  - 클래스 불변식(class invariant): 메서드 실행 전과 후에도 만족해야하는 조건
- LSP의 관점에서 보자면 서브 타입과 슈퍼타입의 관계는 서브타입이 슈퍼타입이 사용자와 맺은 계약을 준수해야한다는 의미이다. 이 원칙을 위반하는 경우는 *오버라이딩*시에 발생한다. LSP를 만족하려면 서브타입의 사전조건은 부모의 사전조건보다 더 약해야하며, 사후조건은 더 강력해야 한다. 이렇게 해야 사용자 입장에서는 부모와 자식을 구분하지 못하게 된다.
- LSP가 하고자하는 말은 상속을 할 때에는, 특히 서브타이핑을 하고자 한다면, 부모 클래스가 맺고 있는 계약에 충실한 타입 계층을 구성해야한다는 것이다. 그렇지 않다면 상속을 사용하지 말자. 상속은 재사용성을 위한 유일한 수단이 아니고, 타입 계층을 구현하는 유일한 수단도 아니다.

타입 계층 구현
-----------

- 클래스는 타입과 같지 않다. 클래스는 타입을 구현하는 한 방법.
- 타입 계층은 **행동호환성**을 전제한다. 또한, 타입 계층은 LSP를 만족해야 한다.
- user-defined data type: OOP에서 타입은 퍼블릭 인터페이스를 의미하고 클래스는 퍼블릭 인터페이스와 그에 대한 구현을 동시에 포함하기 때문에 사용자 정의 타입이라고 불린다.


- - -

다형성
======

- 다형성: 하나의 추상 인터페이스에 대해 서로 다른 구현으로 동작할 수 있는 능력. 다형성은 4가지 종류로 나뉜다.
  1. 유니버셜 다형성
    - 매개변수 다형성: generic programming에서 사용하는 방식. 클래스나 메서드의 변수를 임시 타입으로 지정하여 사용하는 시점에서 구체적인 타입을 지정하는 방식
    - 포함 다형성: 서브타입 다형성. 메시지가 동일하더라도 수신하는 객체의 타입에 따라 다르게 동작하는 방식. 상속은 포함다형성을 구현하는 기본적인 방식.
  2. 임시 다형성
    - 오버로딩 다형성: 하나의 클래스 안에서 동일한 이름의 메서드를 매개변수만 다르게 하여 다른 동작을 가능하게 하는 방식
    - 강제 다형성: 프로그래밍 언어가 지원하거나 사용자가 구현한 타입 변환을 이용하여 동일한 연산자를 다양한 타입에 사용할 수 있는 방식. ex) +를 정수끼리하면 정수 덧셈이고 String에 하면 문자열 이어붙이기가 된다.

- 상속의 목적은, 위에서 설명하였듯이, 재사용성이 아닌 타입 계층을 구현하는 것이다.

- 상속은 2가지 관점이 있다: 부모에 정의된 변수를 자식에서 사용하는 *데이터 관점의 상속*, 부모에 정의된 메서드를 자식에서 사용하는 *행동 관점의 상속*. 행동관점의 상속은 자식 클래스에서 부모클래스로 접근할 수 있게 하면서 이루어진다. 자식 클래스에 호출된 메서드가 정의되어 있지 않으면 상위 클래스에서 찾는다. 인스턴스의 변수는 각 인스턴스마다 생성되지만, 인스턴스의 메서드는 클래스 하나당 하나가 생성된다.

- 업캐스팅: 부모 타입으로 생성된 변수에 자식 타입의 객체를 할당하는 것.
- 동적바인딩: 메시지를 처리할 시점에 적절한 메서드를 결정하는 것.
- 업캐스팅과 동적 바인딩은 객체지향에서 다형성을 위한 메커니즘을 제공한다
- 객체가 메시지를 수신하면 컴파일러는 메시지 수신 객체를 가리키는 변수를 생성되고 self가 가리키는 객체의 클래스부터 시작하여 부모 클래스로 메서드 탐색을 한다. 즉, 메서드를 탐색할 때 자식 클래스부터 시작하기 때문에 자식에 선언된 메서드가 호출되는 것. 찾지 못한 메서드는 부모로 *자동 위임*된다. *self*는 해당 객체를 가리키고 변화지 않는다는 것을 기억하고 밑의 코드를 보자. super느 자식 클래스에서 부모 클래스의 구현으로 접근하는 변수이다.

```kt
open class Mother{
    open fun overridedFunction() = println("This is a function of Mother")
    fun functionOnlyInMother() = this.overridedFunction()
}

class Child: Mother(){
    override fun overridedFunction() = println("This is a function of Child")
}

fun main(){
  val m1: Mother = Child()
  val m2: Mother = Mother()

  m1.functionOnlyInMother()// Result: This is a function of Child
  m2.functionOnlyInMother()// Result: This is a function of Mother
}
```

- 위임(delegation): 자신이 수신한 메시지를 자신이 처리하지 않고 다른 객체에게 전달하는 행위. 위임을 할 때는 자신에 대한 정보를 접근할 수 있는 self를 전달한다. 전달하지 않으면 단순 포워딩. 위임은 합성을 이용하여 상속관계를 구현하는 방법이다.

- - -

- OOP에서는 변경을 if-else같은 조건부 로직이 아닌 다형성을 이용해서 해결한다.
- 조건 로직을 다형성을 이용해서 해소하기 위해서는 조건에 맞는 작은 클래스를 설계해야한다. 이 클래스를 분할하는 기준은 변경의 **이유**와 **주기**이다. SRP를 적용하여 클래스를 단 하나의 변경 이유만을 갖도록 설계해야한다.
- 일관성있는 설계를 하기 위해서는 변경되는 부분과 변경되지 않는 부분으로 나누고 변경되는 부분을 서브 타입으로 분리하여 캡슐화를 진행한다.

캡슐화
=====

- 캡슐화: 객체의 내부 구현을 외부에 감추는 것. **information hiding** 이라고도 부른다. 캡슐화는 단순히 데이터를 감추는 것이 아니라 **변화하는 것들을 감추는 것이다**

데이터 캡슐화
--------

- 상태와 행동을 하나로 묶고, 객체 내부의 데이터에는 오직 퍼블릭 메서드를 통해서만 접근하게하는 캡슐화
- 인터페이스와 구현의 구분을 위한 전제 조건.

은닉화
---

- 객체 내부에 오직 공용 인터페이스에서만 접근 가능하도록 하는 캡슐화
- 내부를 외부에서 보호해서 자율성을 보장한다


- 개념적 무결성: 유사한 기능에 유사한 협력 패턴을 적용하는 것. 시스템의 설계 일관성을 의미한다.

- - -

기능 & 구조
=========

- 사람들의 요구사항은 계속 변하기 때문에 변화하는 대상인 기능에 초점을 두지 말아야 함.
- 객체지향에서는 자주 변경되는 기능이 아닌 안정적인 구조를 기반으로 시스템을 구성. 특히, 객체지향에서는 사람들이 갖는 관점을 시스템에 반영하기 쉬움. 좋은 기능은 좋은 시스템의 필요 조건이며, 좋은 구조는 좋은 시스템의 충분 조건이다.
- 좋은 구조는 변경을 예측해서 미리 구조를 만드는 것이 아니라 변경이 일어 날 수 있다는 것을 염두에 두고 변경에 대응할 수 있는 구조를 만드는 것이다.


- 기능: 시스템을 사용하는 사용자가 원하는 것. **usecase**에 해당
- 구조: 시스템의 설계 형태. **domain model**에 해당

- 도메인 모델: 시스템이 사용되는 영역에서의 개념과 관계 등을 추상화한 것. 도메인 모델을 설계할 때는 사용자들이 시스템에 대해 갖고 있는 *mental model*(시스템에 대해서 생각으로 갖고 있는 추상화 모델)에 일치해야 한다. 설계자의 디자인 모델 <-구현-> 시스템 <-사용-> 사용자의 멘탈 모델와 같이 사용자와 설계자는 시스템을 사이에 놓고 소통한다. 즉, 설계자는 디자인 모델을 이용하여 시스템을 설계할 때 사용자가 갖는 멘탈 모델과 일치하도록 노력해야 한다.
- 사용자들은 보통 멘탈 모델을 생각할 때 객체지향의 방식으로 생각한다. 즉, 객체지향을 이용하면 사용자의 멘탈 모델을 반영한 도메인 모델을 설계하기 쉬워진다.

- 표현적 차이
  - 객체지향설계는 현실 자체를 표현하는 것이 아닌 현실의 특징들을 은유적으로 추상화한다
  - 가끔은 현실의 객체와 다른 객체로 시스템을 설계해야할 때가 있다. 이 차이를 **표현적 차이**라고 한다.

- 도메인 모델을 이용하면 구조가 (상대적으로) 안정적이다: 도메인 모델은 사용자가 갖고 있는 모델을 목적으로 설계된다. 그리고 사용자의 모델은 비교적 변경될 확률이 적기 때문에 사용자의 모델을 목적으로 구조를 설계하면 변경이 적어지고 변경에 대응하기 쉽게 된다.


- 유스케이스
  - usecase: 시스템과 사용자간의 계약을 액터, 응답, 조건에 따른 행위 등으로 서술하는 것. 시나리오들의 집합
  - scenario: usecase을 통해 시스템을 사용하는 하나의 흐름. usecase instance라고도 부름. ex) usecase-회원가입, scenario-아이디가 중복되는 경우에 4xx에러 던짐.
  - usecase는 UI와 관련된 내용을 알지 못해야 한다. i.e. UI에 종속되지 않아야 한다.
  - 유스케이스는 내부 설계와 관련된 정보를 몰라야 한다.
- 유스케이스는 시스템의 외부관점에서 접근하기 때문에 내부 설계와 구현에 대한 어떠한 정보도 알지 못해야한다. 유스케이스는 단지 시나리오들을 묶은 텍스트이다.

구현
-----

- OOP에서는 모든 것이 객체: 개발자들은 시스템을 가장 첫 책임(사용자의 메시지)를 부여 받는 객체라고 생각해야 한다. 이 시스템 객체 안에는 작은 객체들이 상호작용을 하는 구조.
- 시스템에 책임 할당 -> 도메인 모델을 바탕으로 작은 책임으로 세분화햐고 적절한 객체에게 할당 -> 객체들을 클래스로 구현 ====> **재귀적 합성**

- OOP에서는 도메인 모델링의 방법으로 구현도 할 수 있다는 것이다. 이를 **연결 완전성** 이라고 한다. 이는 역으로도 성립해서 구현을 통해서 도메인 모델을 유추할 수도 있다. 이는 **가역성(reversibility)**이라고 함. 결국, 코드의 수정은 도메인 모델의 수정과 항상 같은 경우에 일어나야한다.

- - -

관점
====

- OOP에는 3가지 관점이 존재
  - conceptual perspective: 설계가 도메인 안에 존재하는 개념과 관계를 표현. 사용자가 도메인을 바라보는 관점을 반영하기 때문에 실제 도메인 규칙과 제약사항을 최대한 유사하게 반영해야 함
  - specification perspective: 사용자의 영역을 넘어서 시스템 내의 객체들의 책임에 초점을 맞추는 관점. 인터페이스에 초점을 맞춰서 객체의 협력내의 책임에 초점을 맞춘다(what에 초점을 맞춤)
  - implementation perspective: 실제 코드와 연관되어있는 관점. 객체들이 책임을 수행하기 위한 코드를 작성하는 것에 초점을 둔다(how)

- 하나의 클래스를 설계할 때 위 3가지의 관점을 모두 반영해야한다. 클래스의 개념(개념적 관점)+클래스의 인터페이스(명세적 관점)+클래스의 동작 방식(구현적 관점).
- 역할-책임-협력을 이용하는 것은 객체의 인터페이스를 식별하는 행동이고 이는 명세적 관점에서의 객체 설계이다.

example
--------

- 커피를 주문하는 시스템을 설계
- 개념적 관점: 커피머신, 메뉴, 바리스타 등을 개념화 하고 그 관계를 설계
- 명세적 관점: 각 객체들의 인터페이스(책임)를 설계. ex) 커피머신의 dripCoffee 메서드
- 구현적 관점: 객체들의 책임을 구현함

- - -

추상화 기법
=========

- 추상화는 도메인의 복잡성을 단순화하고 멘탈 모델을 만드는데에 사용됨

개념과 범주
-------

- 개념: 속성과 행위가 유사한 객체에 공통적으로 적용되는 아이디어
- 분류: 객체를 범주로 묶는 것으로 객체들에 공통 개념을 적용하는 것을 의미
- 타입: 하나의 개념.
- 인스턴스화: 분류의 반대과정. 타입으로부터 객체를 만드는 과정
- 클래스: 타입을 구현한 것. **타입과 동일하지 않다**.

패키지
------------

- 클래스가 많아지면 전체적인 구조를 알기 어려움.
- 패키지, 모듈: 전체적인 구조를 표현하기 위해 관련이 있는 클래스들을 하나의 단위로 묶는 것
- 클래스 그룹을 캡슐화해서 복잡도를 낮출 수 있다.

- - -

디자인 패턴
========

- 디자인 패턴: 소프트웨어 설계에서 반복적으로 나타나는 문제에 대해 적용할 수 있는 해결 방법. 일관성 있고 유연한 설계를 재사용하는 것이 목적. 패턴의 요소들은 클래스가 아니라 역할이다.
- 패턴이 설계의 목표가 되어서는 안된다. 목표로 도달 할 수 있는 설계 방법을 제시한다고 생각해야 한다. 맹목적인 패턴 추구는 패턴의 한 요소인 Context를 무시하고 패턴의 구조와 역할만 생각하게 한다. 패턴을 적용하면 안되는 상황에 대한 경험을 쌓아야 한다.
- 패턴은 유연한 설계를 추구하고 유연한 설계는 복잡도를 높이기 때문에 단순하거나 유연성이 필요없는 상황에서 패턴을 적용하는 것은 주객전도된 설계를 하는 것.
